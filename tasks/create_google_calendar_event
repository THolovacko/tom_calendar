#! /usr/bin/ruby

require_relative '../lib/tom_calendar.rb'
require 'time'
require 'tzinfo'

# https://developers.google.com/calendar/create-events
# https://developers.google.com/calendar/v3/reference/events
# https://tools.ietf.org/html/rfc5545#section-3.8.5
# https://icalendar.org/rrule-tool.html

# @current: test
# @remember: should limit image file size


event = JSON.parse(ARGV[0])
event_has_no_end = event['end_date'].nil? || (event['end_date'] == '') || (event['end_date'] == 'TBD')
repeat_txt       = event['repeats']
repeats_on_txt   = event['repeats_on']

return if event['is_general_event']
return unless event['start_date']
return if (event['start_date'] == '') || (event['start_date'] == 'TBD')
return if event['start_date'].split.length != 3  # requires month, date, and year
unless event_has_no_end
  return if event['end_date'].split.length != 3
end
return if event_has_no_end && (repeat_txt == 'Does not repeat')

dynamodb              = Aws::DynamoDB::Client.new(region: ENV['AWS_REGION'])
google_authorizer     = get_google_authorizer(dynamodb)
service               = Google::Apis::CalendarV3::CalendarService.new
service.authorization = google_authorizer.get_credentials(event['google_id'])
service.client_options.application_name = 'TomCalendar'.freeze

start_date      = nil
start_date_time = nil
end_date        = nil
end_date_time   = nil
is_all_day      = false

if event['start_time'] && (event['start_time'] != 'TBD') && (event['start_time'] != '')
  start_date_time = Time.parse("#{event['start_date']} #{event['start_time']}").xmlschema[0..18]
  end_date_time   = Time.parse("#{event['end_date']} #{event['end_time']}").xmlschema[0..18] unless event_has_no_end
else
  start_date = Time.parse(event['start_date']).strftime("%Y-%m-%d")
  end_date   = Time.parse(event['end_date']).strftime("%Y-%m-%d") unless event_has_no_end
  is_all_day = true
end

return if !is_all_day && ( event['end_time'].nil? || (event['end_time'] == '') || (event['end_time'] == 'TBD') )

if is_all_day && (repeat_txt == 'Does not repeat') && (event['start_date'] != event['end_date'])
  # 86400 seconds -> 1day
  end_date = ( Time.parse(event['end_date']) + 86400 ).strftime("%Y-%m-%d") unless event_has_no_end
end

rrule = nil
unless repeat_txt == 'Does not repeat'
  frequency = 'DAILY'   if repeat_txt.include? 'day'
  frequency = 'WEEKLY'  if repeat_txt.include? 'week'
  frequency = 'MONTHLY' if repeat_txt.include? 'month'
  frequency = 'YEARLY'  if repeat_txt.include? 'year'

  interval = /\d\d\d|\d\d|\d/.match(repeat_txt).to_s
  interval = 1 if interval == ''

  rrule = "RRULE:FREQ=#{frequency};INTERVAL=#{interval}"

  case frequency
  when 'WEEKLY'
    rrule_on_days = []
    ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'].each do |weekday|
      if repeats_on_txt.include?(weekday) || repeats_on_txt.include?(weekday[0..2])
        rrule_on_days.push(weekday[0..1].upcase)
      end
    end
    rrule << ";BYDAY=#{rrule_on_days.join(',')}"
  when 'MONTHLY'
    if repeats_on_txt == 'On the same day each month'
      rrule_by_month_day = Time.parse(event['start_date']).strftime("%-d")
      rrule << ";BYMONTHDAY=#{rrule_by_month_day}"
    elsif (/\d/.match(repeats_on_txt))
      rrule_by_month_day = /\d/.match(repeats_on_txt).to_s
      ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'].each do |weekday|
        if repeats_on_txt.include?(weekday)
          rrule_by_month_day << weekday[0..1].upcase
          break
        end
      end
      rrule << ";BYDAY=#{rrule_by_month_day}"
    elsif repeats_on_txt == 'On the last day'
      rrule << ";BYMONTHDAY=28,29,30,31;BYSETPOS=-1"
    else # on last selected weekday
      ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'].each do |weekday|
        if repeats_on_txt.include?(weekday)
          rrule << ";BYDAY=-1#{weekday[0..1].upcase}"
          break
        end
      end
    end
  when 'YEARLY'
    rrule << ";BYMONTH=#{Time.parse(event['start_date']).strftime("%-m")};BYMONTHDAY=#{Time.parse(event['start_date']).strftime("%-d")}"
  end

  unless event_has_no_end
    if is_all_day
      until_date = Time.parse("#{event['end_date']} #{event['end_time'] || ''}").xmlschema[0..9].gsub('-','')
    else
      parsed_time = Time.parse("#{event['end_date']} #{event['end_time']}")
      until_date  = "#{TZInfo::Timezone.get(event['time_zone']).local_to_utc(parsed_time).xmlschema[0..18].gsub('-','').gsub(':','')}Z"
    end
    rrule << ";UNTIL=#{until_date}"
  end

  end_date_time = Time.parse("#{event['start_date']} #{event['end_time']}").xmlschema[0..18] unless is_all_day
  end_date      = start_date
end

google_event = Google::Apis::CalendarV3::Event.new(
  summary: event['title'],
  location: event['location'],
  description: event['description'],
  start: Google::Apis::CalendarV3::EventDateTime.new(
    date: start_date,
    date_time: start_date_time,
    time_zone: event['time_zone']
  ),
  end: Google::Apis::CalendarV3::EventDateTime.new(
    date: end_date,
    date_time: end_date_time,
    time_zone: event['time_zone']
  ),
  recurrence: [
    rrule
  ],
  extended_properties: { 'private': { 'tomcalendar_id': "#{event['google_id']}-#{event['title']}" } }
)

begin
  params = {
    table_name: 'GoogleCalendarIDs',
    key: { google_id: event['google_id'] }
  }

  result_item = dynamodb.get_item(params)&.item || {}
  google_calendar_id = result_item['google_calendar_id']
rescue Exception => e
  print StatusCodeStr::error_message(e.message)
  return
end

begin
  service.insert_event(google_calendar_id, google_event) # @remember: if api fail then retry
rescue Exception => e
  raise "#{rrule}\n#{e}"
end
